{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tinyso3 \u00b6 tinsso3 is a compact and efficient library designed to handle 3D rotations using various mathematical representations including rotation matrices, quaternions, and Lie groups (SO(3)). Whether you're working on robotics, computer graphics, or aerospace applications, tinsso3 provides the essential tools for managing and manipulating 3D rotational data with precision and ease. repository link . tinsso3 implements and demonstrates each of these representations and their interconversions, along with practical examples and applications in 3D rotation and kinematics. Each representation of 3D rotations has its advantages and limitations. Rotation Matrices are straightforward but can be redundant. Euler Angles are intuitive but can suffer from gimbal lock. Axis-Angle is compact and great for interpolation, while Quaternions provide a robust solution for smooth rotations without gimbal lock. Rotational Kinematics provides the framework to understand and predict rotational movements over time. Special advantage of tinyso3 \u00b6 tinyso3 try to cover all ambiguous conventions used by various fields. Rotation Matrix ACTIVE(ALIBI) and PASSIVE(ALIAS) Euler Angles Intrinsic and Extrinsic Proper(XYX, XZX, YXY, YZY, ZXZ, ZYZ) and Tait-Bryan(XYZ, XZY, YXZ, YZX, ZXY, ZYX) Axis-Angle Quaternion Hamilton and JPL Rotational Kinematics","title":"Home"},{"location":"#tinyso3","text":"tinsso3 is a compact and efficient library designed to handle 3D rotations using various mathematical representations including rotation matrices, quaternions, and Lie groups (SO(3)). Whether you're working on robotics, computer graphics, or aerospace applications, tinsso3 provides the essential tools for managing and manipulating 3D rotational data with precision and ease. repository link . tinsso3 implements and demonstrates each of these representations and their interconversions, along with practical examples and applications in 3D rotation and kinematics. Each representation of 3D rotations has its advantages and limitations. Rotation Matrices are straightforward but can be redundant. Euler Angles are intuitive but can suffer from gimbal lock. Axis-Angle is compact and great for interpolation, while Quaternions provide a robust solution for smooth rotations without gimbal lock. Rotational Kinematics provides the framework to understand and predict rotational movements over time.","title":"tinyso3"},{"location":"#special-advantage-of-tinyso3","text":"tinyso3 try to cover all ambiguous conventions used by various fields. Rotation Matrix ACTIVE(ALIBI) and PASSIVE(ALIAS) Euler Angles Intrinsic and Extrinsic Proper(XYX, XZX, YXY, YZY, ZXZ, ZYZ) and Tait-Bryan(XYZ, XZY, YXZ, YZX, ZXY, ZYX) Axis-Angle Quaternion Hamilton and JPL Rotational Kinematics","title":"Special advantage of tinyso3"},{"location":"axis_angle/","text":"Axis-Angle \u00b6 Rodrigues' rotation formula We denote a vector, \\(\\vec{v}'\\) from a vector, \\(\\vec{v}\\) rotated with a given axis of rotation \\(\\vec{k}\\) by an angle \\(\\theta\\) . \\[ \\vec{v}'=\\vec{v}\\cos\\theta+(\\vec{k} \\times \\vec{v})\\sin\\theta + \\vec{k}(\\vec{k} \\cdot \\vec{v})(1-\\cos\\theta)=(I+\\sin\\theta(\\vec{k}^\\times)+(1-\\cos\\theta)(\\vec{k}^\\times)^2)\\vec{v} \\] \\[ ((\\vec{k}^\\times)^2 = \\vec{k}\\vec{k}^T - I) \\] And this is exactly same context of ACTIVE(ALIBI) rotation matrix. \\[ R_{active}=I+\\sin\\theta(\\vec{k}^\\times)+(1-\\cos\\theta)(\\vec{k}^\\times)^2 \\] As a PASSIVE(ALIAS) rotation matrix, you need to transpose the ACTIVE rotation matrix. \\[ R_{passive}=I-\\sin\\theta(\\vec{k}^\\times)+(1-\\cos\\theta)(\\vec{k}^\\times)^2 \\] Derive Axis-Angle from Rotation Matrix \u00b6 \\(\\theta=\\cos^{-1}(\\frac{tr(R)-1}{2}) + 2\\pi m\\) \\(\\vec{k}^{\\times}=\\frac{R-R^T}{2\\sin\\theta}\\) (ACTIVE) \\(\\vec{k}^{\\times}=\\frac{R^T-R}{2\\sin\\theta}\\) (PASSIVE)","title":"Axis-Angle"},{"location":"axis_angle/#axis-angle","text":"Rodrigues' rotation formula We denote a vector, \\(\\vec{v}'\\) from a vector, \\(\\vec{v}\\) rotated with a given axis of rotation \\(\\vec{k}\\) by an angle \\(\\theta\\) . \\[ \\vec{v}'=\\vec{v}\\cos\\theta+(\\vec{k} \\times \\vec{v})\\sin\\theta + \\vec{k}(\\vec{k} \\cdot \\vec{v})(1-\\cos\\theta)=(I+\\sin\\theta(\\vec{k}^\\times)+(1-\\cos\\theta)(\\vec{k}^\\times)^2)\\vec{v} \\] \\[ ((\\vec{k}^\\times)^2 = \\vec{k}\\vec{k}^T - I) \\] And this is exactly same context of ACTIVE(ALIBI) rotation matrix. \\[ R_{active}=I+\\sin\\theta(\\vec{k}^\\times)+(1-\\cos\\theta)(\\vec{k}^\\times)^2 \\] As a PASSIVE(ALIAS) rotation matrix, you need to transpose the ACTIVE rotation matrix. \\[ R_{passive}=I-\\sin\\theta(\\vec{k}^\\times)+(1-\\cos\\theta)(\\vec{k}^\\times)^2 \\]","title":"Axis-Angle"},{"location":"axis_angle/#derive-axis-angle-from-rotation-matrix","text":"\\(\\theta=\\cos^{-1}(\\frac{tr(R)-1}{2}) + 2\\pi m\\) \\(\\vec{k}^{\\times}=\\frac{R-R^T}{2\\sin\\theta}\\) (ACTIVE) \\(\\vec{k}^{\\times}=\\frac{R^T-R}{2\\sin\\theta}\\) (PASSIVE)","title":"Derive Axis-Angle from Rotation Matrix"},{"location":"euler_angles/","text":"Euler Angles \u00b6 Representing Attitude: Euler Angles, Unit Quaternions, and Rotation Vectors Euler angles are a way to describe the orientation of a rigid body in three-dimensional space. They are defined by three successive rotations around different axes. There are two main types of Euler angles: extrinsic and intrinsic. There exists twelve possible sequences of rotation axes, divided in two groups. Proper Euler Angles (zxz, xyx, yzy, zyz, xzx, yxy) Tait-Briyan angles (xyz, yzx, zxy, xzy, zyx, yxz) For first and last angle, the valid range could be [- \\(\\pi\\) , \\(\\pi\\) ] Second angle covers \\(\\pi\\) radians, it could be [ \\(0\\) , \\(\\pi\\) ] or [- \\(\\pi/2\\) , \\(\\pi/2\\) ] Proper Euler Angles has gimbal lock on \\(n\\pi\\) Tait-Briyan angles has gimbal lock on \\(\\pi/2 + n\\pi\\) Intrinsic Euler Angles \u00b6 Intrinsic Euler angles describe rotations about the axes of a moving coordinate system (body frame). Here's how they work: First Rotation (\u03b1): Rotate the object around its own axis. Second Rotation (\u03b2): Rotate the object around its own axis, which has moved with the first rotation. Third Rotation (\u03b3): Rotate the object around its own axis, which has moved with the first two rotations. Build ACTIVE Rotation matrix from Intrinsic Euler Angle \\(R = R_{I \\rightarrow \\alpha \\rightarrow \\beta \\rightarrow \\gamma} = R_{\\alpha}R_{\\beta}R_{\\gamma}\\) Build PASSIVE Rotation matrix from Intrinsic Euler Angle \\(R = R_{\\gamma \\leftarrow \\beta \\leftarrow \\alpha \\leftarrow I} = R_{\\gamma}R_{\\beta}R_{\\alpha}\\) (Be aware that \\(R_{?}\\) is differ depends on ACTIVE or PASSIVE) Extrinsic Euler Angles \u00b6 Extrinsic Euler angles describe rotations about the axes of a fixed coordinate system (global frame). Here's how they work: First Rotation (\u03b1): Rotate the object around the fixed axis. Second Rotation (\u03b2): Rotate the object around the fixed axis. Third Rotation (\u03b3): Rotate the object around the fixed axis. Build ACTIVE Rotation matrix from Extrinsic Euler Angle \\(R = R_{\\gamma \\leftarrow \\beta \\leftarrow \\alpha \\leftarrow I} = R_{\\gamma}R_{\\beta}R_{\\alpha}\\) Build PASSIVE Rotation matrix from Extrinsic Euler Angle \\(R = R_{I \\rightarrow \\alpha \\rightarrow \\beta \\rightarrow \\gamma} = R_{\\alpha}R_{\\beta}R_{\\gamma}\\) (Be aware that \\(R_{?}\\) is differ depends on ACTIVE or PASSIVE) See Representing Attitude: Euler Angles, Unit Quaternions, and Rotation Vectors for detailed derivation This document describes about conversion between PASSIVE Rotation matrix and Intrinsic Euler Angles. This document uses \\(\\psi\\) as first angle of rotation, \\(\\theta\\) as second angle of rotation and \\(\\phi\\) as third angle of rotation.","title":"Euler Angles"},{"location":"euler_angles/#euler-angles","text":"Representing Attitude: Euler Angles, Unit Quaternions, and Rotation Vectors Euler angles are a way to describe the orientation of a rigid body in three-dimensional space. They are defined by three successive rotations around different axes. There are two main types of Euler angles: extrinsic and intrinsic. There exists twelve possible sequences of rotation axes, divided in two groups. Proper Euler Angles (zxz, xyx, yzy, zyz, xzx, yxy) Tait-Briyan angles (xyz, yzx, zxy, xzy, zyx, yxz) For first and last angle, the valid range could be [- \\(\\pi\\) , \\(\\pi\\) ] Second angle covers \\(\\pi\\) radians, it could be [ \\(0\\) , \\(\\pi\\) ] or [- \\(\\pi/2\\) , \\(\\pi/2\\) ] Proper Euler Angles has gimbal lock on \\(n\\pi\\) Tait-Briyan angles has gimbal lock on \\(\\pi/2 + n\\pi\\)","title":"Euler Angles"},{"location":"euler_angles/#intrinsic-euler-angles","text":"Intrinsic Euler angles describe rotations about the axes of a moving coordinate system (body frame). Here's how they work: First Rotation (\u03b1): Rotate the object around its own axis. Second Rotation (\u03b2): Rotate the object around its own axis, which has moved with the first rotation. Third Rotation (\u03b3): Rotate the object around its own axis, which has moved with the first two rotations. Build ACTIVE Rotation matrix from Intrinsic Euler Angle \\(R = R_{I \\rightarrow \\alpha \\rightarrow \\beta \\rightarrow \\gamma} = R_{\\alpha}R_{\\beta}R_{\\gamma}\\) Build PASSIVE Rotation matrix from Intrinsic Euler Angle \\(R = R_{\\gamma \\leftarrow \\beta \\leftarrow \\alpha \\leftarrow I} = R_{\\gamma}R_{\\beta}R_{\\alpha}\\) (Be aware that \\(R_{?}\\) is differ depends on ACTIVE or PASSIVE)","title":"Intrinsic Euler Angles"},{"location":"euler_angles/#extrinsic-euler-angles","text":"Extrinsic Euler angles describe rotations about the axes of a fixed coordinate system (global frame). Here's how they work: First Rotation (\u03b1): Rotate the object around the fixed axis. Second Rotation (\u03b2): Rotate the object around the fixed axis. Third Rotation (\u03b3): Rotate the object around the fixed axis. Build ACTIVE Rotation matrix from Extrinsic Euler Angle \\(R = R_{\\gamma \\leftarrow \\beta \\leftarrow \\alpha \\leftarrow I} = R_{\\gamma}R_{\\beta}R_{\\alpha}\\) Build PASSIVE Rotation matrix from Extrinsic Euler Angle \\(R = R_{I \\rightarrow \\alpha \\rightarrow \\beta \\rightarrow \\gamma} = R_{\\alpha}R_{\\beta}R_{\\gamma}\\) (Be aware that \\(R_{?}\\) is differ depends on ACTIVE or PASSIVE) See Representing Attitude: Euler Angles, Unit Quaternions, and Rotation Vectors for detailed derivation This document describes about conversion between PASSIVE Rotation matrix and Intrinsic Euler Angles. This document uses \\(\\psi\\) as first angle of rotation, \\(\\theta\\) as second angle of rotation and \\(\\phi\\) as third angle of rotation.","title":"Extrinsic Euler Angles"},{"location":"quaternion/","text":"Quaternion \u00b6 A quaternion is a four-dimensional complex number used to represent rotations in 3D space. It offers a compact and efficient way to encode rotation without suffering from gimbal lock, which can occur with Euler angles. Quaternions are widely used in various applications such as computer graphics, robotics, and aerospace. A quaternion \\(q\\) is typically expressed as: \\[ q = w + xi + yj + zk \\] Where \\(w, x, y, z\\) are real numbers, and $ i, j, k $ are the fundamental quaternion units. Alternatively, it can be written in vector form as: HAMILTON convention \u00b6 \\[ q = \\begin{bmatrix} w \\\\ \\vec{v} \\end{bmatrix} = \\begin{bmatrix} w \\\\ x \\\\ y \\\\ z \\end{bmatrix} \\] JPL convention \u00b6 The Jet Propulsion Laboratory (JPL) convention differs from Hamilton in the sign of the vector part of the quaternion. It is typically used in aerospace applications. \\[ q = \\begin{bmatrix} \\vec{v} \\\\ w \\end{bmatrix} = \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w \\end {bmatrix} \\] Here, \\(w\\) is the scalar part, and \\(\\vec{v} = \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}\\) is the vector part. Quaternion Algebra \u00b6 Addition : Quaternions are added component-wise: $$ q_1 + q_2 = (w_1 + w_2) + (x_1 + x_2)i + (y_1 + y_2)j + (z_1 + z_2)k $$ Multiplication : Quaternion multiplication is defined as: $$ q_1 q_2 = (w_1 w_2 - \\vec{v}_1 \\cdot \\vec{v}_2) + (w_1 \\vec{v}_2 + w_2 \\vec{v}_1 + \\vec{v}_1 \\times \\vec{v}_2) $$ This can also be written in matrix form. Conjugate : The conjugate of a quaternion is: $$ q^* = w - xi - yj - zk $$ Norm : The norm of a quaternion is: $$ |q| = \\sqrt{w^2 + x^2 + y^2 + z^2} $$ Inverse : The inverse of a quaternion is: $$ q^{-1} = \\frac{q^*}{|q|^2} $$ Rotation Representation \u00b6 To represent a rotation by an angle \\(\\theta\\) around a unit vector \\(\\hat{u}\\) : \\[ q = \\cos\\left(\\frac{\\theta}{2}\\right) + \\hat{u} \\sin\\left(\\frac{\\theta}{2}\\right) \\] Where \\(\\hat{u} = \\begin{bmatrix} u_x \\\\ u_y \\\\ u_z \\end{bmatrix}\\) is the axis of rotation. Applying Rotation \u00b6 To rotate a vector \\(\\vec{v}\\) using a quaternion \\(q\\) : Convert the vector to a quaternion with a zero scalar part: $$ \\vec{v} \\rightarrow q_v = 0 + v_x i + v_y j + v_z k $$ Perform the rotation: $$ q' = q q_v q^{-1} $$ The resulting vector \\(\\vec{v}'\\) is extracted from \\(q'\\) . Composition of Multiple Quaternions \u00b6 In the Hamilton convention, quaternion multiplication is used to compose rotations. If you have two quaternions, \\(q_1\\) and \\(q_2\\) , representing two rotations, the composition of these rotations is achieved by multiplying the quaternions. The product of two quaternions \\(q_1\\) and \\(q_2\\) is: Where: \\[q_1 = w_1 + x_1 i + y_1 j + z_1 k\\] \\[q_2 = w_2 + x_2 i + y_2 j + z_2 k\\] The resulting quaternion \\(q\\) is: \\[ q = (w_1 w_2 - x_1 x_2 - y_1 y_2 - z_1 z_2) + (w_1 x_2 + x_1 w_2 + y_1 z_2 - z_1 y_2) i + (w_1 y_2 + y_1 w_2 + z_1 x_2 - x_1 z_2) j + (w_1 z_2 + z_1 w_2 + x_1 y_2 - y_1 x_2) k \\] Spherical Linear Interpolation (SLERP) \u00b6 SLERP is used to interpolate smoothly between two quaternions. It ensures constant angular velocity and produces the shortest path on the unit sphere. Given two quaternions \\(q_1\\) and \\(q_2\\) , SLERP between them for \\(t \\in [0, 1]\\) is defined as: \\[ \\text{slerp}(q_1, q_2, t) = \\frac{\\sin((1 - t) \\theta) q_1 + \\sin(t \\theta) q_2}{\\sin(\\theta)} \\] Where $ \\theta $ is the angle between \\(q_1\\) and \\(q_2\\) : \\[ \\cos(\\theta) = q_1 \\cdot q_2 \\]","title":"Quaternion"},{"location":"quaternion/#quaternion","text":"A quaternion is a four-dimensional complex number used to represent rotations in 3D space. It offers a compact and efficient way to encode rotation without suffering from gimbal lock, which can occur with Euler angles. Quaternions are widely used in various applications such as computer graphics, robotics, and aerospace. A quaternion \\(q\\) is typically expressed as: \\[ q = w + xi + yj + zk \\] Where \\(w, x, y, z\\) are real numbers, and $ i, j, k $ are the fundamental quaternion units. Alternatively, it can be written in vector form as:","title":"Quaternion"},{"location":"quaternion/#hamilton-convention","text":"\\[ q = \\begin{bmatrix} w \\\\ \\vec{v} \\end{bmatrix} = \\begin{bmatrix} w \\\\ x \\\\ y \\\\ z \\end{bmatrix} \\]","title":"HAMILTON convention"},{"location":"quaternion/#jpl-convention","text":"The Jet Propulsion Laboratory (JPL) convention differs from Hamilton in the sign of the vector part of the quaternion. It is typically used in aerospace applications. \\[ q = \\begin{bmatrix} \\vec{v} \\\\ w \\end{bmatrix} = \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w \\end {bmatrix} \\] Here, \\(w\\) is the scalar part, and \\(\\vec{v} = \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}\\) is the vector part.","title":"JPL convention"},{"location":"quaternion/#quaternion-algebra","text":"Addition : Quaternions are added component-wise: $$ q_1 + q_2 = (w_1 + w_2) + (x_1 + x_2)i + (y_1 + y_2)j + (z_1 + z_2)k $$ Multiplication : Quaternion multiplication is defined as: $$ q_1 q_2 = (w_1 w_2 - \\vec{v}_1 \\cdot \\vec{v}_2) + (w_1 \\vec{v}_2 + w_2 \\vec{v}_1 + \\vec{v}_1 \\times \\vec{v}_2) $$ This can also be written in matrix form. Conjugate : The conjugate of a quaternion is: $$ q^* = w - xi - yj - zk $$ Norm : The norm of a quaternion is: $$ |q| = \\sqrt{w^2 + x^2 + y^2 + z^2} $$ Inverse : The inverse of a quaternion is: $$ q^{-1} = \\frac{q^*}{|q|^2} $$","title":"Quaternion Algebra"},{"location":"quaternion/#rotation-representation","text":"To represent a rotation by an angle \\(\\theta\\) around a unit vector \\(\\hat{u}\\) : \\[ q = \\cos\\left(\\frac{\\theta}{2}\\right) + \\hat{u} \\sin\\left(\\frac{\\theta}{2}\\right) \\] Where \\(\\hat{u} = \\begin{bmatrix} u_x \\\\ u_y \\\\ u_z \\end{bmatrix}\\) is the axis of rotation.","title":"Rotation Representation"},{"location":"quaternion/#applying-rotation","text":"To rotate a vector \\(\\vec{v}\\) using a quaternion \\(q\\) : Convert the vector to a quaternion with a zero scalar part: $$ \\vec{v} \\rightarrow q_v = 0 + v_x i + v_y j + v_z k $$ Perform the rotation: $$ q' = q q_v q^{-1} $$ The resulting vector \\(\\vec{v}'\\) is extracted from \\(q'\\) .","title":"Applying Rotation"},{"location":"quaternion/#composition-of-multiple-quaternions","text":"In the Hamilton convention, quaternion multiplication is used to compose rotations. If you have two quaternions, \\(q_1\\) and \\(q_2\\) , representing two rotations, the composition of these rotations is achieved by multiplying the quaternions. The product of two quaternions \\(q_1\\) and \\(q_2\\) is: Where: \\[q_1 = w_1 + x_1 i + y_1 j + z_1 k\\] \\[q_2 = w_2 + x_2 i + y_2 j + z_2 k\\] The resulting quaternion \\(q\\) is: \\[ q = (w_1 w_2 - x_1 x_2 - y_1 y_2 - z_1 z_2) + (w_1 x_2 + x_1 w_2 + y_1 z_2 - z_1 y_2) i + (w_1 y_2 + y_1 w_2 + z_1 x_2 - x_1 z_2) j + (w_1 z_2 + z_1 w_2 + x_1 y_2 - y_1 x_2) k \\]","title":"Composition of Multiple Quaternions"},{"location":"quaternion/#spherical-linear-interpolation-slerp","text":"SLERP is used to interpolate smoothly between two quaternions. It ensures constant angular velocity and produces the shortest path on the unit sphere. Given two quaternions \\(q_1\\) and \\(q_2\\) , SLERP between them for \\(t \\in [0, 1]\\) is defined as: \\[ \\text{slerp}(q_1, q_2, t) = \\frac{\\sin((1 - t) \\theta) q_1 + \\sin(t \\theta) q_2}{\\sin(\\theta)} \\] Where $ \\theta $ is the angle between \\(q_1\\) and \\(q_2\\) : \\[ \\cos(\\theta) = q_1 \\cdot q_2 \\]","title":"Spherical Linear Interpolation (SLERP)"},{"location":"rotation_matrix/","text":"Rotation Matrix \u00b6 A rotation matrix is a way to describe a relationship between cartesian coordinate system. Reference coordinate system is referred as Global | World | Inertial | Fixed The other one is referred as Local | Body | Relative | Moving In this section, we refer Inertial as a reference coordinate system, and Body as the other coordinate system. Here, we denote Inertial and Body frame as \\[ \\vec{I}= \\begin{bmatrix} \\vec{I}_x \\\\ \\vec{I}_y \\\\ \\vec{I}_z \\\\ \\end{bmatrix},\\ \\vec{B}= \\begin{bmatrix} \\vec{B}_x \\\\ \\vec{B}_y \\\\ \\vec{B}_z \\\\ \\end{bmatrix} \\] A (arbitrary) vector expressed in each frame, \\(v_I\\) and \\(v_B\\) is the component of vector expressed in each frame. \\[\\vec{v}=\\vec{I}^Tv_I=\\vec{B}^Tv_B\\] Relationship between \\(v_I\\) and \\(v_B\\) \\[ v_B=B \\cdot \\vec{I}^T v_I = R_{BI} v_I = \\begin{bmatrix} \\vec{B}_x \\cdot \\vec{I}_x \\ \\ \\ \\ \\vec{B}_x \\cdot \\vec{I}_y \\ \\ \\ \\ \\vec{B}_x \\cdot \\vec{I}_z \\\\ \\vec{B}_y \\cdot \\vec{I}_x \\ \\ \\ \\ \\vec{B}_y \\cdot \\vec{I}_y \\ \\ \\ \\ \\vec{B}_y \\cdot \\vec{I}_z \\\\ \\vec{B}_z \\cdot \\vec{I}_x \\ \\ \\ \\ \\vec{B}_z \\cdot \\vec{I}_y \\ \\ \\ \\ \\vec{B}_z \\cdot \\vec{I}_z \\\\ \\end{bmatrix} v_I \\] \\[ v_I=I \\cdot \\vec{B}^T v_B = R_{IB} v_B = \\begin{bmatrix} \\vec{I}_x \\cdot \\vec{B}_x \\ \\ \\ \\ \\vec{I}_x \\cdot \\vec{B}_y \\ \\ \\ \\ \\vec{I}_x \\cdot \\vec{B}_z \\\\ \\vec{I}_y \\cdot \\vec{B}_x \\ \\ \\ \\ \\vec{I}_y \\cdot \\vec{B}_y \\ \\ \\ \\ \\vec{I}_y \\cdot \\vec{B}_z \\\\ \\vec{I}_z \\cdot \\vec{B}_x \\ \\ \\ \\ \\vec{I}_z \\cdot \\vec{B}_y \\ \\ \\ \\ \\vec{I}_z \\cdot \\vec{B}_z \\\\ \\end{bmatrix} v_B \\] Hence, \\[R_{BI}=R_{IB}^T= R_{IB}^{-1}\\] \\[R_{IB}=R_{BI}^T= R_{BI}^{-1}\\] ACTIVE(ALIBI) and PASSIVE(ALIAS) interpretation \u00b6 ACTIVE Interpretation \u00b6 We want to rotate a vector from \\(\\vec{v}\\) to \\(\\vec{v}'\\) , to have same component in body frame. $$ \\vec{v} = \\vec{I}^T\\vec{v}_I $$ \\[ \\vec{v}' = \\vec{B}^T\\vec{v}_I = \\vec{I}^T\\vec{v}'_I \\] Hence, \\[ \\vec{v}'_I = \\vec{I} \\cdot \\vec{B}^T\\vec{v}_I = R_{IB} \\vec{v}_I = R \\vec{v}_I \\] PASSIVE Interpretation \u00b6 We want to express a (same) vector in the body frame. \\[ v_B=B \\cdot \\vec{I}^T v_I = R_{BI} v_I = R v_I \\] Understandably, Rotation Matrix \\(R\\) is different depend on the interpretations. You need to properly select one of interpretation from context, when you read documents without explicit explanations. Principal Rotations \u00b6 ACTIVE PASSIVE \\(R_x(\\theta)\\) \\(\\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & \\cos \\theta & -\\sin \\theta \\\\ 0 & \\sin \\theta & \\cos \\theta \\\\ \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & \\cos \\theta & \\sin \\theta \\\\ 0 & -\\sin \\theta & \\cos \\theta \\\\ \\end{bmatrix}\\) \\(R_y(\\theta)\\) \\(\\begin{bmatrix}\\cos \\theta & 0 & \\sin \\theta \\\\0 & 1 & 0 \\\\-\\sin \\theta & 0 & \\cos \\theta \\\\\\end{bmatrix}\\) \\(\\begin{bmatrix}\\cos \\theta & 0 & -\\sin \\theta \\\\0 & 1 & 0 \\\\\\sin \\theta & 0 & \\cos \\theta \\\\\\end{bmatrix}\\) \\(R_z(\\theta)\\) \\(\\begin{bmatrix}\\cos \\theta & -\\sin \\theta & 0 \\\\\\sin \\theta & \\cos \\theta & 0 \\\\0 & 0 & 1 \\\\\\end{bmatrix}\\) \\(\\begin{bmatrix}\\cos \\theta & \\sin \\theta & 0 \\\\-\\sin \\theta & \\cos \\theta & 0 \\\\0 & 0 & 1 \\\\\\end{bmatrix}\\) Exponential & Logarithm \u00b6 The matrix exponential is \\(\\exp(A) = 1 + A + \\frac{1}{2!}A^2 + \\frac{1}{3!}A^3+\\cdots=\\sum_{n=0}^{\\infty}\\frac{1}{n!}A^n\\) \\(R=\\exp({\\mathbf{\\hat{\\phi}}})=\\exp(\\phi \\hat{a})=\\cos\\phi+(1-\\cos\\phi)aa^T+\\sin\\phi\\hat{a}\\) \\(\\phi=\\cos^{-1}(\\frac{tr(R)-1}{2}) + 2\\pi m\\) \\(\\hat{a}=\\frac{R-R^T}{2\\sin\\theta}\\) \\(R^\\alpha=\\exp(\\hat{\\phi})^{\\alpha}=\\exp(\\alpha\\hat{\\phi})\\) Interpolation \u00b6 \\(R = R_1(R_1^TR_2)^{\\alpha}\\) (ACTIVE) \\(R = (R_2R_1^T)^{\\alpha}R_1\\) (PASSIVE) Normalization \u00b6 \\(R'=(RR^T)^{-\\frac{1}{2}}R\\) ( \\(A^{-\\frac{1}{2}}=\\frac{1}{\\sqrt{\\lambda_1}}e_1e_1^T+\\frac{1}{\\sqrt{\\lambda_2}}e_2e_2^T+\\frac{1}{\\sqrt{\\lambda_3}}e_3e_3^T\\) ) EigenPair of 3x3 Symmetric Matrix Normalization of a (perturbed) rotation matrix is, find a new rotation matrix, close to the perturbed rotation matrix. This can be formulated by, maximize \\[J(R')=tr(R'R^T)-\\frac{1}{2}\\sum^{3}_{i=1}\\sum^{3}_{j=1}\\lambda_{ij}(r^{'T}_{i} r_j^{'} - \\delta_{ij})\\] \\(\\delta_{ij}\\) is Kronecker delta, \\(R^T=[r_1 \\ \\ r_2 \\ \\ r_3]\\) , \\((R')^T=[r_1^{'} \\ \\ r_2^{'} \\ \\ r_3^{'}]\\) Take the derivative of \\(J\\) with respect to the three rows of \\(R'\\) and set to Zero. \\[ [r_1^{'} \\ \\ r_2^{'} \\ \\ r_3^{'}] \\begin{bmatrix} \\lambda_{11} & \\lambda_{12} & \\lambda_{13} \\\\ \\lambda_{21} & \\lambda_{22} & \\lambda_{23} \\\\ \\lambda_{31} & \\lambda_{32} & \\lambda_{33} \\\\ \\end{bmatrix} = [r_1 \\ \\ r_2 \\ \\ r_3] \\] due to symmetry of lagrange multiplier terms, \\(\\lambda_{ij}=\\lambda_{ji}\\) \\[\\lambda R' = R, \\ \\ \\lambda = \\lambda ^ T\\] \\[ \\lambda ^ 2 = \\lambda \\lambda^T = RR^T \\rightarrow \\lambda = (RR^T)^\\frac{1}{2} \\] \\[\\ \\ \\therefore R'=(RR^T)^{-\\frac{1}{2}}R\\]","title":"Rotation Matrix"},{"location":"rotation_matrix/#rotation-matrix","text":"A rotation matrix is a way to describe a relationship between cartesian coordinate system. Reference coordinate system is referred as Global | World | Inertial | Fixed The other one is referred as Local | Body | Relative | Moving In this section, we refer Inertial as a reference coordinate system, and Body as the other coordinate system. Here, we denote Inertial and Body frame as \\[ \\vec{I}= \\begin{bmatrix} \\vec{I}_x \\\\ \\vec{I}_y \\\\ \\vec{I}_z \\\\ \\end{bmatrix},\\ \\vec{B}= \\begin{bmatrix} \\vec{B}_x \\\\ \\vec{B}_y \\\\ \\vec{B}_z \\\\ \\end{bmatrix} \\] A (arbitrary) vector expressed in each frame, \\(v_I\\) and \\(v_B\\) is the component of vector expressed in each frame. \\[\\vec{v}=\\vec{I}^Tv_I=\\vec{B}^Tv_B\\] Relationship between \\(v_I\\) and \\(v_B\\) \\[ v_B=B \\cdot \\vec{I}^T v_I = R_{BI} v_I = \\begin{bmatrix} \\vec{B}_x \\cdot \\vec{I}_x \\ \\ \\ \\ \\vec{B}_x \\cdot \\vec{I}_y \\ \\ \\ \\ \\vec{B}_x \\cdot \\vec{I}_z \\\\ \\vec{B}_y \\cdot \\vec{I}_x \\ \\ \\ \\ \\vec{B}_y \\cdot \\vec{I}_y \\ \\ \\ \\ \\vec{B}_y \\cdot \\vec{I}_z \\\\ \\vec{B}_z \\cdot \\vec{I}_x \\ \\ \\ \\ \\vec{B}_z \\cdot \\vec{I}_y \\ \\ \\ \\ \\vec{B}_z \\cdot \\vec{I}_z \\\\ \\end{bmatrix} v_I \\] \\[ v_I=I \\cdot \\vec{B}^T v_B = R_{IB} v_B = \\begin{bmatrix} \\vec{I}_x \\cdot \\vec{B}_x \\ \\ \\ \\ \\vec{I}_x \\cdot \\vec{B}_y \\ \\ \\ \\ \\vec{I}_x \\cdot \\vec{B}_z \\\\ \\vec{I}_y \\cdot \\vec{B}_x \\ \\ \\ \\ \\vec{I}_y \\cdot \\vec{B}_y \\ \\ \\ \\ \\vec{I}_y \\cdot \\vec{B}_z \\\\ \\vec{I}_z \\cdot \\vec{B}_x \\ \\ \\ \\ \\vec{I}_z \\cdot \\vec{B}_y \\ \\ \\ \\ \\vec{I}_z \\cdot \\vec{B}_z \\\\ \\end{bmatrix} v_B \\] Hence, \\[R_{BI}=R_{IB}^T= R_{IB}^{-1}\\] \\[R_{IB}=R_{BI}^T= R_{BI}^{-1}\\]","title":"Rotation Matrix"},{"location":"rotation_matrix/#activealibi-and-passivealias-interpretation","text":"","title":"ACTIVE(ALIBI) and PASSIVE(ALIAS) interpretation"},{"location":"rotation_matrix/#active-interpretation","text":"We want to rotate a vector from \\(\\vec{v}\\) to \\(\\vec{v}'\\) , to have same component in body frame. $$ \\vec{v} = \\vec{I}^T\\vec{v}_I $$ \\[ \\vec{v}' = \\vec{B}^T\\vec{v}_I = \\vec{I}^T\\vec{v}'_I \\] Hence, \\[ \\vec{v}'_I = \\vec{I} \\cdot \\vec{B}^T\\vec{v}_I = R_{IB} \\vec{v}_I = R \\vec{v}_I \\]","title":"ACTIVE Interpretation"},{"location":"rotation_matrix/#passive-interpretation","text":"We want to express a (same) vector in the body frame. \\[ v_B=B \\cdot \\vec{I}^T v_I = R_{BI} v_I = R v_I \\] Understandably, Rotation Matrix \\(R\\) is different depend on the interpretations. You need to properly select one of interpretation from context, when you read documents without explicit explanations.","title":"PASSIVE Interpretation"},{"location":"rotation_matrix/#principal-rotations","text":"ACTIVE PASSIVE \\(R_x(\\theta)\\) \\(\\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & \\cos \\theta & -\\sin \\theta \\\\ 0 & \\sin \\theta & \\cos \\theta \\\\ \\end{bmatrix}\\) \\(\\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & \\cos \\theta & \\sin \\theta \\\\ 0 & -\\sin \\theta & \\cos \\theta \\\\ \\end{bmatrix}\\) \\(R_y(\\theta)\\) \\(\\begin{bmatrix}\\cos \\theta & 0 & \\sin \\theta \\\\0 & 1 & 0 \\\\-\\sin \\theta & 0 & \\cos \\theta \\\\\\end{bmatrix}\\) \\(\\begin{bmatrix}\\cos \\theta & 0 & -\\sin \\theta \\\\0 & 1 & 0 \\\\\\sin \\theta & 0 & \\cos \\theta \\\\\\end{bmatrix}\\) \\(R_z(\\theta)\\) \\(\\begin{bmatrix}\\cos \\theta & -\\sin \\theta & 0 \\\\\\sin \\theta & \\cos \\theta & 0 \\\\0 & 0 & 1 \\\\\\end{bmatrix}\\) \\(\\begin{bmatrix}\\cos \\theta & \\sin \\theta & 0 \\\\-\\sin \\theta & \\cos \\theta & 0 \\\\0 & 0 & 1 \\\\\\end{bmatrix}\\)","title":"Principal Rotations"},{"location":"rotation_matrix/#exponential-logarithm","text":"The matrix exponential is \\(\\exp(A) = 1 + A + \\frac{1}{2!}A^2 + \\frac{1}{3!}A^3+\\cdots=\\sum_{n=0}^{\\infty}\\frac{1}{n!}A^n\\) \\(R=\\exp({\\mathbf{\\hat{\\phi}}})=\\exp(\\phi \\hat{a})=\\cos\\phi+(1-\\cos\\phi)aa^T+\\sin\\phi\\hat{a}\\) \\(\\phi=\\cos^{-1}(\\frac{tr(R)-1}{2}) + 2\\pi m\\) \\(\\hat{a}=\\frac{R-R^T}{2\\sin\\theta}\\) \\(R^\\alpha=\\exp(\\hat{\\phi})^{\\alpha}=\\exp(\\alpha\\hat{\\phi})\\)","title":"Exponential &amp; Logarithm"},{"location":"rotation_matrix/#interpolation","text":"\\(R = R_1(R_1^TR_2)^{\\alpha}\\) (ACTIVE) \\(R = (R_2R_1^T)^{\\alpha}R_1\\) (PASSIVE)","title":"Interpolation"},{"location":"rotation_matrix/#normalization","text":"\\(R'=(RR^T)^{-\\frac{1}{2}}R\\) ( \\(A^{-\\frac{1}{2}}=\\frac{1}{\\sqrt{\\lambda_1}}e_1e_1^T+\\frac{1}{\\sqrt{\\lambda_2}}e_2e_2^T+\\frac{1}{\\sqrt{\\lambda_3}}e_3e_3^T\\) ) EigenPair of 3x3 Symmetric Matrix Normalization of a (perturbed) rotation matrix is, find a new rotation matrix, close to the perturbed rotation matrix. This can be formulated by, maximize \\[J(R')=tr(R'R^T)-\\frac{1}{2}\\sum^{3}_{i=1}\\sum^{3}_{j=1}\\lambda_{ij}(r^{'T}_{i} r_j^{'} - \\delta_{ij})\\] \\(\\delta_{ij}\\) is Kronecker delta, \\(R^T=[r_1 \\ \\ r_2 \\ \\ r_3]\\) , \\((R')^T=[r_1^{'} \\ \\ r_2^{'} \\ \\ r_3^{'}]\\) Take the derivative of \\(J\\) with respect to the three rows of \\(R'\\) and set to Zero. \\[ [r_1^{'} \\ \\ r_2^{'} \\ \\ r_3^{'}] \\begin{bmatrix} \\lambda_{11} & \\lambda_{12} & \\lambda_{13} \\\\ \\lambda_{21} & \\lambda_{22} & \\lambda_{23} \\\\ \\lambda_{31} & \\lambda_{32} & \\lambda_{33} \\\\ \\end{bmatrix} = [r_1 \\ \\ r_2 \\ \\ r_3] \\] due to symmetry of lagrange multiplier terms, \\(\\lambda_{ij}=\\lambda_{ji}\\) \\[\\lambda R' = R, \\ \\ \\lambda = \\lambda ^ T\\] \\[ \\lambda ^ 2 = \\lambda \\lambda^T = RR^T \\rightarrow \\lambda = (RR^T)^\\frac{1}{2} \\] \\[\\ \\ \\therefore R'=(RR^T)^{-\\frac{1}{2}}R\\]","title":"Normalization"},{"location":"rotational_kinematics/","text":"Rotational Kinematics \u00b6 Here, Three topics are described. Definition of angular velocity Derivative of Rotation Matrix Relationship between Angular Velocity and Euler Rate Definition of angular velocity \u00b6 Let frame \\(\\vec{B}\\) rotate with respect to frame \\(\\vec{I}\\) . The angular velocity of frame \\(\\vec{B}\\) respect to frame \\(\\vec{I}\\) is denoted by \\(\\vec{\\omega}_{BI} = -\\vec{\\omega}_{IB}\\) Starts with a basic theorem, without demonstration, \\[ \\dot{\\vec{I}}^T = 0, \\ \\ \\dot{\\vec{B}}^T = \\vec{\\omega}_{BI} \\times \\vec{B}^T \\] Derivative of Rotation Matrix \u00b6 \\[B^T R_{BI} = I^T\\] Take derivative of both side, \\[\\vec{\\omega}_{BI} \\times \\vec{B}^TR_{BI} + \\vec{B}^T \\dot{R}_{BI} = \\vec{B}^T \\vec{\\omega}_{BI}^B \\times \\vec{B}^TR_{BI} + \\vec{B}^T \\dot{R}_{BI} = 0\\] \\[\\therefore \\ \\ \\dot{R}_{BI}= R_{BI} [\\vec{\\omega}_{BI}^B]^\\times\\] or, from \\[I^T R_{IB} = B^T\\] derive \\[\\therefore \\ \\ \\dot{R}_{IB}= - [\\vec{\\omega}_{BI}^B]^\\times R_{IB}\\] Relationship between Angular Velocity and Euler Rate \u00b6 PASSIVE or ACTIVE does not affects relationship between Angular Velocity and Euler Rate . However, Intrinsic or Extrinsic affects relationship between Angular Velocity and Euler Rate . Here we derive relationship between Angular Velocity and Euler Rate of generalized euler angle \\(\\alpha \\rightarrow \\beta \\rightarrow \\gamma\\) with arbitrary axis of rotation. Case of Intrinsic Euler Angle \u00b6 \\(R = R_{\\gamma \\leftarrow \\beta \\leftarrow \\alpha \\leftarrow I} = R_{\\gamma}R_{\\beta}R_{\\alpha}\\) (PASSIVE) In case of principal axis rotation, \\[\\therefore \\ \\ -\\dot{R_i}R_i^T= [1_i]^\\times{\\dot{\\theta}}_i\\] and using, \\[[Rv]^\\times=Rv^\\times R^T\\] \\[ \\dot{R}=\\dot{R}_\\gamma R_\\beta R_\\alpha + R_\\gamma \\dot{R}_\\beta R_\\alpha + R_\\gamma R_\\beta \\dot{R}_\\alpha = - [\\omega]^\\times (R_\\gamma R_\\beta R_\\alpha) \\] \\[ \\therefore \\ \\ \\omega = [R_\\gamma R_\\beta 1_1 \\ \\ R_\\gamma 1_2 \\ \\ 1_3] \\begin{bmatrix} \\dot{\\alpha} \\\\ \\dot{\\beta} \\\\ \\dot{\\gamma} \\end{bmatrix} \\] Case of Extrinsic Euler Angle \u00b6 \\(R = R_{I \\rightarrow \\alpha \\rightarrow \\beta \\rightarrow \\gamma} = R_{\\alpha}R_{\\beta}R_{\\gamma}\\) (PASSIVE) \\[ \\therefore \\ \\ \\omega = [1_1 \\ \\ R_\\alpha 1_2 \\ \\ R_\\alpha R_\\beta 1_1] \\begin{bmatrix} \\dot{\\alpha} \\\\ \\dot{\\beta} \\\\ \\dot{\\gamma} \\end{bmatrix} \\]","title":"Rotational Kinematics"},{"location":"rotational_kinematics/#rotational-kinematics","text":"Here, Three topics are described. Definition of angular velocity Derivative of Rotation Matrix Relationship between Angular Velocity and Euler Rate","title":"Rotational Kinematics"},{"location":"rotational_kinematics/#definition-of-angular-velocity","text":"Let frame \\(\\vec{B}\\) rotate with respect to frame \\(\\vec{I}\\) . The angular velocity of frame \\(\\vec{B}\\) respect to frame \\(\\vec{I}\\) is denoted by \\(\\vec{\\omega}_{BI} = -\\vec{\\omega}_{IB}\\) Starts with a basic theorem, without demonstration, \\[ \\dot{\\vec{I}}^T = 0, \\ \\ \\dot{\\vec{B}}^T = \\vec{\\omega}_{BI} \\times \\vec{B}^T \\]","title":"Definition of angular velocity"},{"location":"rotational_kinematics/#derivative-of-rotation-matrix","text":"\\[B^T R_{BI} = I^T\\] Take derivative of both side, \\[\\vec{\\omega}_{BI} \\times \\vec{B}^TR_{BI} + \\vec{B}^T \\dot{R}_{BI} = \\vec{B}^T \\vec{\\omega}_{BI}^B \\times \\vec{B}^TR_{BI} + \\vec{B}^T \\dot{R}_{BI} = 0\\] \\[\\therefore \\ \\ \\dot{R}_{BI}= R_{BI} [\\vec{\\omega}_{BI}^B]^\\times\\] or, from \\[I^T R_{IB} = B^T\\] derive \\[\\therefore \\ \\ \\dot{R}_{IB}= - [\\vec{\\omega}_{BI}^B]^\\times R_{IB}\\]","title":"Derivative of Rotation Matrix"},{"location":"rotational_kinematics/#relationship-between-angular-velocity-and-euler-rate","text":"PASSIVE or ACTIVE does not affects relationship between Angular Velocity and Euler Rate . However, Intrinsic or Extrinsic affects relationship between Angular Velocity and Euler Rate . Here we derive relationship between Angular Velocity and Euler Rate of generalized euler angle \\(\\alpha \\rightarrow \\beta \\rightarrow \\gamma\\) with arbitrary axis of rotation.","title":"Relationship between Angular Velocity and Euler Rate"},{"location":"rotational_kinematics/#case-of-intrinsic-euler-angle","text":"\\(R = R_{\\gamma \\leftarrow \\beta \\leftarrow \\alpha \\leftarrow I} = R_{\\gamma}R_{\\beta}R_{\\alpha}\\) (PASSIVE) In case of principal axis rotation, \\[\\therefore \\ \\ -\\dot{R_i}R_i^T= [1_i]^\\times{\\dot{\\theta}}_i\\] and using, \\[[Rv]^\\times=Rv^\\times R^T\\] \\[ \\dot{R}=\\dot{R}_\\gamma R_\\beta R_\\alpha + R_\\gamma \\dot{R}_\\beta R_\\alpha + R_\\gamma R_\\beta \\dot{R}_\\alpha = - [\\omega]^\\times (R_\\gamma R_\\beta R_\\alpha) \\] \\[ \\therefore \\ \\ \\omega = [R_\\gamma R_\\beta 1_1 \\ \\ R_\\gamma 1_2 \\ \\ 1_3] \\begin{bmatrix} \\dot{\\alpha} \\\\ \\dot{\\beta} \\\\ \\dot{\\gamma} \\end{bmatrix} \\]","title":"Case of Intrinsic Euler Angle"},{"location":"rotational_kinematics/#case-of-extrinsic-euler-angle","text":"\\(R = R_{I \\rightarrow \\alpha \\rightarrow \\beta \\rightarrow \\gamma} = R_{\\alpha}R_{\\beta}R_{\\gamma}\\) (PASSIVE) \\[ \\therefore \\ \\ \\omega = [1_1 \\ \\ R_\\alpha 1_2 \\ \\ R_\\alpha R_\\beta 1_1] \\begin{bmatrix} \\dot{\\alpha} \\\\ \\dot{\\beta} \\\\ \\dot{\\gamma} \\end{bmatrix} \\]","title":"Case of Extrinsic Euler Angle"}]}